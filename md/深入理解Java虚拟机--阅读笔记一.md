#  Java内存区域

##  一、java运行时数据区域

1、
程序计数器：程序计数器占据的内存空间较小，是当前运行线程执行的字节码的计数；分支、循环、跳转、异常处理、线程恢复等都要依赖技术器来对执行的字节码进行执行位置的计算来实现的。程序计数器的内存空间是每条线程独有的，也称之为“线程私有”的内存；计数器记录的是正在运行的字节码指令的地址，而如果是Native方法（本地方法），则计数器的值为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

2、java虚拟机栈：java虚拟机栈也是线程私有的，它的生命周期与线程相同。每个方法在运行的时候都会创建一个栈帧（Stack
Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的调用，就对应着一个栈帧在虚拟机栈种从入栈到出栈的过程。局部变量表中存储了编译期可知的各种基本数据类型，（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型。java虚拟机栈会抛出StackOverflowError异常和OutOfMemoryError异常。

3、本地方法栈：本地方法栈是本地方法的“java虚拟机栈”。

4、Java堆：Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”；根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展实现的（当然可以是固定的），通过-
Xmx和-Xms控制。当没有内存可以完成对象的实例的分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

5、方法区：方法区也是被线程共享的，它存储的是：被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-
Heap（非堆），目的应该是与Java堆区分开来。

对于Java堆从内存回收的角度来看，Java堆可以分为新生代和和老年代；很多人愿意把方法区称为“永久代”（限于HotSpot虚拟机）；根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

6、运行时常量池：时方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。因为运行期间也可能会因为String类的intern（）方法来将新的常量放入池中，所以当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

##  二、对象的创建

1、
虚拟机遇到一条new的指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有就先进类的加载过程，在类加载完成后为新生对象分配内存。而分配内存的分配算法被受到收集器的算法的影响。在使用Serial、ParNew等带Compact过程（压缩）的收集器时，系统采用的分配算法是“指针碰撞”；而使用CMS这种基础MARK-
Sweep算法（标记-清理算法）的收集器时，系统采用的分配算法是”空闲列表“；

2、虚拟机为保证线程安全的两种内存分配机制：第一种是对分配内存空间的动作进行同步处理--
实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是采用本地线程分配缓冲（TLAB）。虚拟机在内存分配完成后把内存空间初始化为零值（不包括对象头），TLAB是分配的同时进行初始化。这样对象的初始值就不是空而是零，可以在不手动赋值的情况下进行调用。

##  三、对象的内存布局

1、对象在内存中存储的布局可以分为三个区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。

2、对象头包括两部分：第一部分用于存储对象的运行时数据（如：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的ID、偏向时间戳等）；另一部分是类型指针，即指向其类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。java数组的记录长度的数据也会存在对象头中，虚拟机可以通过普通java对象的元数据信息确定java对象的大小。

3、实例数据就是类中定义的各个字段的实例数据。

4、对齐填充不是必然存在的，由于HotSpot
VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象示例数据部分没有对齐时，就需要通过对齐填充来补全。

##  四、对象的访问定位

1、访问对象有使用句柄和直接指针两种方式；都是通过存在Java虚拟机栈本地变量表中的reference指向Java堆来找到对象。

2、使用句柄的方式：通过reference来访问Java堆中专门划分出来的句柄池（这时reference中存储的就是对象的句柄的地址），而句柄池中的句柄包含了到对象示例数据的指针和到对象类型数据的指针；存放对象实例对象的实例池在Java堆中，对象类型数据在方法区。这种方法的好处就是在对象移动时（垃圾收集时经常移动对象）只需要改变句柄中的指向对象实例数据的指针。

3、使用直接指针访问，reference直接指向对象实例数据和到对象类型数据的指针。这种方式的好处就是更快，

