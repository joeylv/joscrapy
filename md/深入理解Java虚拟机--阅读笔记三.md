# 垃圾收集器

手机算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。

并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

并发：值用户线程与垃圾收集线程同时执行（但并不一定是并行的），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

### Serial收集器

单线程收集器，也就是说是必须停止所有的工作线程，知道垃圾收集完毕。对于单CPU来说更加高效。所以适合运行于Client模式下的虚拟机。

新生代采用复制算法。老年代采用标记整理算法。

### ParNew收集器

是Serial的多线程版本（看图的话是在新生代多线程同时进行GC）。是GC线程有多个，所有其他工作线程都停止。多线程GC会有线程间交互这种上下文切换的效率损失。

新生代采用复制算法。老年代采用标记整理算法。

### Parallel Scavenge收集器

多线程同时GC。这款收集器的目的是更高的吞吐量。是吞吐量优先收集器，高吞吐量会使得GC停顿时间变长。但总体的用户运行代码时间变多了。吞吐量：运行用户代码时间/（运行用户代码时间+垃圾收集时间）

该收集器既可以自动调节也可以通过手动配置来优化收集过程。

### Serial Old收集器

单线程收集器，标记整理算法。是Serial的老年代版本。

### Parallel Old收集器

是Parallel Scavenge收集器的老年代版本 标记整理算法。

解决了只能和Serial Old收集器搭配的尴尬境地。

### CMS收集器

Concurrent Mark Sweep 收集器是以获取最短回收停顿时间为目的的收集器。B/S应用关注用户的体验，更短的响应时间。CMS这点很适合。

从名字来看，并发标记清除。是一款可以和用户线程并发的收集器。

分为四个步骤：初始标记、并发标记、重新标记、并发清除。其中初始标记和重新标记需要stop the world，也就是停止其他工作线程。

初始标记步骤标记所有GC Roots直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots
Tracing（追踪）的过程。重新标记是修正并发标记阶段用户线程继续运行而发生的改变。并发清除就不用说了。

整个过程最耗时的追踪和清除实现了并发。而标记GC Roots和重新标记耗时很短。

缺点：1、占用用户线程的CPU。影响用户体验。占用线程数为（CPU数量+3）/4，CPU越多占用的越少。

2、无法处理浮动垃圾，所以老年代要预留空间。可以上调老年代GC阈值来调优，但是太高会造成“Concurrent Mode
Failure”失败。造成启用备用方案Serial Old来GC老年代，造成长时间停顿。反而降低性能

3、标记清除会造成老年代空间碎片太多，如果有大对象会引发Full GC。默认是每次Full
GC都进行整理，可以设置次数来优化。（如果程序涉及大对象就多整理，如果不涉及就可以很少的整理）

### G1收集器

特点：

1、并发与并行

2、分代收集 （所有收集器都是分代的）

3、空间整合

4、可预测的停顿

Garbage First收集器是整堆收集器。虽然还保留新生代和老年代的概念，但是他们都是一部分Region的集合，而不再有物理隔离。

