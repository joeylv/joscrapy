# 垃圾收集器与内存分配策略

##  一、判断对象是否已死

1、垃圾收集器在对堆进行回收前，要先判断对象是否已死。而判断的算法有引用计数算法和可达性分析算法；

2、引用计数算法是给对象添加引用计数器，有地方引用就加1，当引用失效就减1，任何时刻计数器为0的对象就是不可能再被引用的。但是它很难解决对象之间相互循环引用。所以在主流的Java虚拟机里没有用引用计数算法来管理内存。

3、可达性分析算法是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference
Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。在Java语言中，可作为GC
Roots的对象包括下面几种：虚拟机栈（栈帧中的本地变量表）中引用的对象；方法区中类静态属性引用的对象；方法区中常量引用的对象；本地方法栈中JNI（即一般说的Native方法）引用的对象。

4、引用在JDK1.2之后分为强引用，软引用，弱引用，需引用。

5、即使在可达性分析后不可达的对象也至少要经历两次标记过程，第一次是可达性分析后没有与GC
Roots相关联的引用链，就会被标记进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法，当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，那么就被是为“没有必要执行”，如果执行的对象与引用链上的任何一个对象建立了关联即可拯救自己。

##  二、垃圾收集算法

1、标记-清除算法、标记-整理算法、复制算法、分代收集算法；

2、分代收集算法是根据对象存活周期的不同来划分为老年代和新生代（默认是15个周期）；在新生代中因为有大量对象会死去所以采用的复制算法，在新生代区域中分为一个Eden和两个Survivor区域，新建对象分配到Eden和其中一个Survivor中，每次清理后将活着的对象复制到Survivor区域；HotSpot虚拟机的默认比例是8：1；而老年代中对象存活率高，一般采用标记-
清除或者标记-整理算法来进行GC。

##  三、HotShot算法实现

1、枚举根节点：进行可达性分析，从可作为GC
Roots的节点查找引用链，可达性分析时会产生GC停顿。并且使用OopMap的数据结构来使得虚拟机可以直接得知哪里存放着对象的引用。HotShot在安全点会停下进行GC。而为了让所有线程在安全点停顿，有两种方案，抢先式中断和主动式中断。还有安全区域概念。

##  四、垃圾收集器

1、Serial收集器时最基本、发展历史最悠久的收集器，单线程收集器。

2、ParNew收集器其实就是Serial收集器的多线程版本

3、Parallel
Scavenge收集器是一个新生代收集器，它也是使用复制方法的收集器又是并行的多线程收集器。它不同于CMS等收集器的关注点是减少停顿时间，他的目标是达到一个可控制的吞吐量。

4、Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。

5、Parallel Old是Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。

6、CMS收集器是一种以获取最短回收停顿时间为目标的收集器，使用“标记-清除”算法。

7、G1收集器是当今收集器技术发展的最前沿成果之一，G1具有以下特点：并行与并发；分代收集；空间整合；可预测的停顿。

##  五、内存分配与回收策略

1、在Serial/Serial Old收集器下，大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够内存是，发起一次Minor GC。

2、大对象直接进入老年代。通过-
XX：pretenureSizeThreshold参数来设置对象大小的界限，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

3、长期存活的对象将进入老年代 默认经历过15次Minor GC后进入老年代

4、动态对象年龄判定如果在Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

5、空间分配担保：发生Minor
GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，不安全的话会再计算之前每一次回收晋升到老年代对象容量的平均大小之作为经验值，与老年代的剩余空间进行比较，决定是否进行Full
GC来让老年代腾出更多空间。

